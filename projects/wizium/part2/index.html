<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Jean-Sébastien Gonsette  | De la bonne façon de paver sa grille</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.55.6" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    <link href='https://jsgonsette.github.io/dist/main.css' rel='stylesheet' type="text/css" />
    <link href='https://jsgonsette.github.io/css/jsg.css' rel='stylesheet' type="text/css" />
    <link href='https://jsgonsette.github.io/css/socialSharing.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="De la bonne façon de paver sa grille" />
<meta property="og:description" content="La méthode utilisée précédemment pour remplir la grille se voulait excessivement naïve, car il est tout à fait catastrophique de ne tester la validité de la solution qu&rsquo;une fois tous les mots placés. Le problème étant combinatoire, la nature exponentielle des combinaisons de mots s&rsquo;affiche comme autant de branches, branchettes et puis brindilles se subdivisant effroyablement rapidement. Aussi vaut-il mieux se rendre compte le plus tôt possible que la voie choisie n&rsquo;aboutira à aucune solution, de manière à couper la branche morte dès le début et ne pas perdre du précieux temps de calcul au fin fond de son arborescence." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jsgonsette.github.io/projects/wizium/part2/" />
<meta property="article:published_time" content="2019-05-19T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-05-19T00:00:00&#43;00:00"/>

<meta itemprop="name" content="De la bonne façon de paver sa grille">
<meta itemprop="description" content="La méthode utilisée précédemment pour remplir la grille se voulait excessivement naïve, car il est tout à fait catastrophique de ne tester la validité de la solution qu&rsquo;une fois tous les mots placés. Le problème étant combinatoire, la nature exponentielle des combinaisons de mots s&rsquo;affiche comme autant de branches, branchettes et puis brindilles se subdivisant effroyablement rapidement. Aussi vaut-il mieux se rendre compte le plus tôt possible que la voie choisie n&rsquo;aboutira à aucune solution, de manière à couper la branche morte dès le début et ne pas perdre du précieux temps de calcul au fin fond de son arborescence.">


<meta itemprop="datePublished" content="2019-05-19T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-05-19T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2181">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="De la bonne façon de paver sa grille"/>
<meta name="twitter:description" content="La méthode utilisée précédemment pour remplir la grille se voulait excessivement naïve, car il est tout à fait catastrophique de ne tester la validité de la solution qu&rsquo;une fois tous les mots placés. Le problème étant combinatoire, la nature exponentielle des combinaisons de mots s&rsquo;affiche comme autant de branches, branchettes et puis brindilles se subdivisant effroyablement rapidement. Aussi vaut-il mieux se rendre compte le plus tôt possible que la voie choisie n&rsquo;aboutira à aucune solution, de manière à couper la branche morte dès le début et ne pas perdre du précieux temps de calcul au fin fond de son arborescence."/>

      
    
  </head>

  <body class="ma0 avenir bg-near-white">

    

  
  
  <header class="cover bg-top" style="background-image: url('https://jsgonsette.github.io/images/Wizium/PavingFlat.jpg');">
    <div class="pb3-m pb6-l bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jsgonsette.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Jean-Sébastien Gonsette
    </a>
    <div class="flex-l items-center">
      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/42/" title="42 page">
              42
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/enigmes/" title="Énigmes page">
              Énigmes
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="Billets page">
              Billets
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/projects/" title="Projets page">
              Projets
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/contact/" title="À propos page">
              À propos
            </a>
          </li>
          
        </ul>
      
      






  <a href="https://www.linkedin.com/in/jsgonsette/" class="link-transition linkedin link dib z-999 pt3 pt0-l mr2" title="LinkedIn link">
    <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

  </a>


  <a href="https://github.com/jsgonsette" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>


    </div>
  </div>
</nav>

      <div class="tc-l pv6 ph3 ph4-ns">
        <h1 class="f2 f1-l fw2 white-90 mb0 lh-title">De la bonne façon de paver sa grille</h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <p class="f6 b helvetica tracked">
          
            Wizium - Mon générateur de mots croisés
          
        </p>
        <h1 class="f1">
          De la bonne façon de paver sa grille
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
        <span class="justified">
        <p>La méthode utilisée précédemment pour remplir la grille se voulait excessivement naïve, car il est tout à fait catastrophique de ne tester la validité de la solution qu&rsquo;une fois tous les mots placés. Le problème étant combinatoire, la nature exponentielle des combinaisons de mots s&rsquo;affiche comme autant de branches, branchettes et puis brindilles se subdivisant effroyablement rapidement. Aussi vaut-il mieux se rendre compte le plus tôt possible que la voie choisie n&rsquo;aboutira à aucune solution, de manière à couper la branche morte dès le début et ne pas perdre du précieux temps de calcul au fin fond de son arborescence.</p>

<p>



  


<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="/js/load-photoswipe.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin="anonymous"></script>


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

</p>

<p>Reste maintenant à savoir quelle est la manière la plus efficace pour procéder, de façon à anticiper aussi vite que possible une quelconque situation de blocage. Je ne prétends pas détenir la réponse ultime à cette question et je me contenterai de présenter deux méthodes possibles, l&rsquo;une d&rsquo;elles est celle implémentée dans Wizum.</p>

<h2 id="première-méthode-le-tressage">Première méthode: le tressage</h2>

<p>Cette technique est assez naturelle et consiste à alterner la pose des mots horizontalement et verticalement, de haut en bas et de gauche à droite. L&rsquo;entrelacement des mots est alors maximal et permet de détecter très tôt l&rsquo;impossibilité de placer un $n^{ème}$ mot. Le cas échéant, il suffira alors de modifier le mot précédent au niveau de la lettre qui a conduit à ce blocage.</p>


<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/Wizium/Weave.gif" alt="Construction par entrelacement vertical-horizontal des mots."/>
    </div>
    <a href="/images/Wizium/Weave.gif" itemprop="contentUrl"></a>
      <figcaption>
          <p>Construction par entrelacement vertical-horizontal des mots.</p>
      </figcaption>
  </figure>
</div>


<p>Dans l&rsquo;exemple ci-dessus, la pose du troisième mot vertical avec <strong>CREOLE</strong> empêche ensuite de placer le quatrième mot horizontal. Il n&rsquo;existe en effet aucune solution de six lettres commençant par <strong>REO</strong>. Cela invalide le mot précédent et conduit immédiatement à le remplacer par quelque chose ne contenant pas de <strong>O</strong> sur la quatrième rangée. Toutes les cases vides de la grille sont alors autant de combinaisons de mots qui ne devront pas être testées.</p>

<p>Essayons maintenant d&rsquo;évaluer le gain que cette méthodologie peut offrir. On peut l&rsquo;étudier en l&rsquo;abordant comme une <strong>chaine de Markov discrète</strong>, c&rsquo;est-à-dire que l&rsquo;algorithme de pavage de la grille peut être assimilé à un processus stochastique dont l&rsquo;état correspond uniquement à l&rsquo;indice du mot à placer. Le succès ou l&rsquo;échec de cette opération conduit soit à avancer au mot suivant ou, au contraire, à reculer pour modifier le précédent. Ce processus n&rsquo;est pas réellement homogène, car techniquement, les probabilités de transitions ne dépendent pas seulement de la partie de la grille que l&rsquo;on essaie de remplir, mais aussi de toutes les combinaisons de lettres qui ont déjà été épuisées. Nous nous contenterons toutefois de cette approximation dans la mesure où nous voulons seulement estimer l&rsquo;ordre de grandeur du gain apporté par cette approche.</p>

<p>Pour ce faire, désignons par ${w_h}_i$ les $S$ emplacements horizontaux et, de la même manière, par ${w_v}_i$ pour les emplacements verticaux. La probabilité qu&rsquo;il existe un mot du dictionnaire pour remplir chacun d&rsquo;eux est donnée par:</p>

<p>$${p_{h}}_i = 1 - (1 - {p_{co}}^i)^N$$</p>

<p>$${p_{v}}_i = 1 - (1 - {p_{co}}^{i+1})^N$$</p>

<p>avec $i=0&hellip;S-1$. Ces formules traduisent simplement la probabilité qu&rsquo;un certain nombre de lettres assemblées au hasard correspondent à une partie de mot valide. Plus $i$ augmente, plus les chances diminuent à cause du nombre croissant de lettres avec lequel il faut composer. Nous pouvons alors modéliser le processus de <em>backtracking</em> par cette chaine de Markov.</p>



<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/Wizium/Markov.png" alt="Chaine de Markov modélisant les probabilités de trouver un mot adéquat pour paver chacun des emplacements de la grille."/>
    </div>
    <a href="/images/Wizium/Markov.png" itemprop="contentUrl"></a>
      <figcaption>
          <p>Chaine de Markov modélisant les probabilités de trouver un mot adéquat pour paver chacun des emplacements de la grille.</p>
      </figcaption>
  </figure>
</div>


<p>Sans trop entrer dans les détails mathématiques, un processus de Markov peut s&rsquo;étudier au travers des propriétés de sa matrice de transition $P$. Celle-ci est construite de telle sorte que chaque élément $(P)_{ij}$ soit égal à la probabilité de transition entre l&rsquo;état $i$ et l&rsquo;état $j$.</p>

<p>$$P=\begin{pmatrix}
    0 &amp; 1-{p_v}_0 &amp; 0  &amp; 0 &amp; 0\newline
    {p_h}_0 &amp; 0 &amp; \ddots &amp; 0 &amp; 0\newline
    0 &amp; {p_v}_0 &amp; 0 &amp; 1-{p_v} _ {S-1} &amp; 0\newline
    0 &amp; 0 &amp; \ddots &amp; 0 &amp; 0 \newline
    0 &amp; 0 &amp; 0 &amp; {p_v} _ {S-1} &amp; 1
\end{pmatrix}$$</p>

<p>de telle sorte que si $\phi(n)$ représente la distribution de probabilité de l&rsquo;état du processus au temps $n$, alors la distribution au pas suivant sera donnée par:</p>

<p>$$\phi(n+1) = P. \phi(n)$$</p>

<p>Le dernier état appelé un état <strong>absorbant</strong>, car il correspond à la construction d&rsquo;une grille complète valide et stoppe la recherche. Cela peut se voir sur le graphe à cause de l&rsquo;unique transition de probabilité 1 qui cycle sur cet état final. Cette propriété se constate aussi dans la dernière colonne de la matrice $P$ qui ne permet pas de redistribuer les probabilités autre part que dans le dernier état. A l&rsquo;inverse, tous les autres états sont dit <strong>transitoires</strong>, dans la mesure ou rien de garantit que l&rsquo;algorithme les traversera plus d&rsquo;une fois. La valeur qu&rsquo;il est alors particulièrement intéressant d&rsquo;étudier concerne <em>le temps passé en moyenne dans ces états transitoires avant d&rsquo;atteindre l&rsquo;état final</em>.</p>

<p>Pour y arriver, il nous faut d&rsquo;abord réécrire la matrice $P$ en mettant en évidence cette distinction, grâce à la matrice carrée $Q$ capturant cet aspect transitoire, ainsi qu&rsquo;au vecteur $R$ représentant l&rsquo;état absorbant.</p>

<p>$$P=\begin{pmatrix}
    Q &amp; \boldsymbol{0}\newline
    R &amp; 1\newline<br />
\end{pmatrix}$$</p>

<p>Cela permet ensuite de calculer la matrice $N = (I-Q)^{-1}$ grâce à laquelle on peut trouver la durée moyenne du transitoire, ou dit autrement, le nombre de pas moyen de l&rsquo;algorithme de <em>backtracking</em> (suivez ce <a href="https://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/Chapter11.pdf">lien</a> pour plus d&rsquo;information à ce sujet).</p>

<p>Examinons maintenant les nouvelles estimations du nombre de pas nécessaires pour résoudre nos grilles parfaites de différentes tailles, afin d&rsquo;apprécier le gain apporté par cette nouvelle méthode.</p>

<table>
<thead>
<tr>
<th align="left">$S$</th>
<th align="center">&nbsp; Nombre de grilles&nbsp;</th>
<th align="right">&nbsp; #pas, naïf &nbsp;</th>
<th align="right">&nbsp; #pas, tressage &nbsp;</th>
<th align="right">&nbsp; Résolution</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"></td>
<td align="center"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">5&nbsp;&nbsp;</td>
<td align="center">$10^{19}$</td>
<td align="right">$10^{8.7}$</td>
<td align="right">$10^{3.4}$</td>
<td align="right">1ms</td>
</tr>

<tr>
<td align="left">6&nbsp;&nbsp;</td>
<td align="center">$10^{24.8}$</td>
<td align="right">$10^{15.0}$</td>
<td align="right">$10^{6.3}$</td>
<td align="right">2s</td>
</tr>

<tr>
<td align="left">7&nbsp;&nbsp;</td>
<td align="center">$10^{30.5}$</td>
<td align="right">$10^{23.7}$</td>
<td align="right">$10^{11}$</td>
<td align="right">1 journée</td>
</tr>

<tr>
<td align="left">8&nbsp;&nbsp;</td>
<td align="center">$10^{36.0}$</td>
<td align="right">$10^{34.8}$</td>
<td align="right">$10^{17.8}$</td>
<td align="right">20.000 ans</td>
</tr>
</tbody>
</table>

<p>La dernière colonne estime à nouveau le temps de résolution à raison d&rsquo;un million de tests par seconde. Il va sans dire que le progrès est spectaculaire, la résolution d&rsquo;une grille 7x7 pouvant maintenant s&rsquo;envisager sans problème, en passant d&rsquo;un temps de 10 milliards d&rsquo;années (ce qui n&rsquo;est pas loin de l&rsquo;âge de l&rsquo;univers) à seulement une journée. Les grilles 8x8 restent toutefois encore hors de portée avec cette méthode, du moins si l&rsquo;on se cantonne à l&rsquo;usage d&rsquo;un PC conventionnel.</p>

<h2 id="deuxième-méthode-l-échafaudage">Deuxième méthode: l&rsquo;échafaudage</h2>

<p>La technique que je m&rsquo;apprête à décrire constitue la base de l&rsquo;algorithme implémenté dans Wizium. Elle résulte avant toute chose d&rsquo;une longue recherche ponctuée de beaucoup d&rsquo;essais et de nombreuses erreurs, et pas de l&rsquo;analyse que vous êtes en train de lire, car cette dernière est arrivée bien plus tard. Malgré son élaboration empirique, son principal avantage est de ne pas souffrir des mêmes faiblesses que la méthode précédente. Elle est beaucoup plus directe et anticipe mieux les problèmes. Pour s&rsquo;en rendre compte, commençons par jeter un oeil à la construction de la grille qui suit:</p>



<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/Wizium/WeaveFail.gif" alt="Construction pathologique par entrelacement vertical horizontal des mots. C&#39;est seulement au dernier stade de l&#39;algorithme que l&#39;impossibilité de la dernière colonne est détectée."/>
    </div>
    <a href="/images/Wizium/WeaveFail.gif" itemprop="contentUrl"></a>
      <figcaption>
          <p>Construction pathologique par entrelacement vertical horizontal des mots. C&#39;est seulement au dernier stade de l&#39;algorithme que l&#39;impossibilité de la dernière colonne est détectée.</p>
      </figcaption>
  </figure>
</div>


<p>Cette construction pathologique a été imaginée sur mesure, mais illustre néanmoins une tare inévitable de la méthode de <em>tressage</em>: lorsque l&rsquo;on place les derniers mots, le succès de l&rsquo;opération joue tout sur la chance et rien sur l&rsquo;anticipation. C&rsquo;est ce qui peut se voir dans cet exemple, la pose du deuxième mot horizontal engendre un blocage inévitable, car il empêche de placer ensuite un mot verticalement sur la dernière colonne. Mais rien dans l&rsquo;algorithme ne permet ensuite de détecter cette impasse et celui-ci continuera laborieusement à construire une grille qui est vouée à l&rsquo;échec. C&rsquo;est seulement lors de la pose du dernier mot que la procédure commencera à revenir en arrière pour résoudre la situation, et il devra pour ça défaire presque toute la grille.</p>

<p>Pour éviter ce genre de contrariétés, il est nécessaire et suffisant de vérifier qu&rsquo;il est encore possible de placer un mot verticalement sur chaque colonne à chaque fois que l&rsquo;on choisit un mot horizontal. Mais en procédant de la sorte, il n&rsquo;est en fait même plus nécessaire de placer aucun mot verticalement. L&rsquo;empilage de mots horizontaux suffit, dans la mesure où celui-ci se réalise de manière éclairée: l&rsquo;algorithme s&rsquo;assure continuellement que l&rsquo;on n&rsquo;aura pas de mauvaise surprise à la fin. Il n&rsquo;est donc plus question ici de jeter les mots en vracs pour espérer en sortir une grille valide, il s&rsquo;agit plutôt d&rsquo;empiler les mots avec soin. Il est bien sûr possible que, à un moment, aucun mot du dictionnaire ne satisfasse cette contrainte. Mais dans ce cas, le blocage est identifié au plus tôt et permet tout de suite de revenir en arrière, sans s&rsquo;embarquer dans une recherche stérile. Cette méthode est illustrée dans l&rsquo;animation qui suit.</p>



<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/Wizium/Wizium.gif" alt="Échafaudage méthodique des mots horizontaux, en vérifiant  systématiquement les emplacements verticaux."/>
    </div>
    <a href="/images/Wizium/Wizium.gif" itemprop="contentUrl"></a>
      <figcaption>
          <p>Échafaudage méthodique des mots horizontaux, en vérifiant  systématiquement les emplacements verticaux.</p>
      </figcaption>
  </figure>
</div>


<p>Outre sa capacité d&rsquo;anticipation, cette méthode nécessite de placer seulement $S$ mots sur la grille, contre $2.S$ mots pour la méthode de tressage. Cela implique que le graphe de Markov correspondant s&rsquo;en trouve raccourci et, moyennant que les probabilités de transition soient favorables, puisse s&rsquo;en trouver plus facile à traverser.</p>

<p>Étudions donc ces probabilités de transition. L&rsquo;approche est la suivante: un mot horizontal peut être placé s&rsquo;il existe au moins un <em>mot vertical compatible</em> sur chacune des colonnes traversées. Il convient tout d&rsquo;abord de se pencher d&rsquo;un peu plus près sur ce nombre de mots compatibles. Il est certain que, plus je m&rsquo;avance dans la construction, plus ce nombre diminue du fait de la longueur plus élevée des préfixes correspondants. Par exemple, lorsque je pose le mot <strong>BRELER</strong>, je dois vérifier qu&rsquo;il existe bien un mot commençant par <strong>HAB</strong>  dans la première colonne. Ce nombre de possibilités est plus élevé que lorsque je pose le mot <strong>ETETER</strong> et que j&rsquo;aie à vérifier qu&rsquo;il existe un mot débutant par <strong>HABLE</strong>.</p>

<p>Le nombre moyen de mots disponibles, étant donné la longueur d&rsquo;un préfixe, se trouve simplement en compilant quelques statistiques sur le dictionnaire utilisé. Ce <a href="https://github.com/jsgonsette/Wizium/blob/master/Scripts/dico_stats.py">script</a> permet de réaliser ce travail et la figure qui suit en illustre quelques chiffres.</p>



<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/Wizium/Prefix.jpg" alt="Nombre moyen de mots disponible, étant donné la longueur du préfixe (valeurs logarithmiques)."/>
    </div>
    <a href="/images/Wizium/Prefix.jpg" itemprop="contentUrl"></a>
      <figcaption>
          <p>Nombre moyen de mots disponible, étant donné la longueur du préfixe (valeurs logarithmiques).</p>
      </figcaption>
  </figure>
</div>


<p>Définissons donc la fonction $M (S, i)$ exprimant le nombre moyen de mots disponibles étant donné une longueur de préfixe $i$. Celle-ci nous permet alors de calculer la probabilité qu&rsquo;une lettre d&rsquo;un mot horizontal placé au niveau $i$ permette toujours de poser un mot verticalement par-dessus.</p>

<p>$${p_ {co}}_i = 1 - (1-p _{co})^{M(S, i)}$$</p>

<p>La probabilité qu&rsquo;un mot donné soit compatible sur chaque colonne est alors donnée par ${{p_ {co}}_i}^S$, ce qui permet finalement de calculer la probabilité de pouvoir placer un mot au niveau $i$:</p>

<p>$${p_ {h}}_i = 1 - (1-{{p _{co}} _i}^S )^N$$</p>

<p>Avant d&rsquo;aller plus loin, il est intéressant de comparer les deux méthodes au niveau de leurs probabilités de transition avec des valeurs concrètes. Celles-ci sont reprises dans la table qui suit pour une grille de 6x6 cases. Non seulement la technique d&rsquo;échafaudage requiert moins d&rsquo;étapes, mais les probabilités de pose sont aussi plus élevées.</p>

<table>
<thead>
<tr>
<th align="left">Étape&nbsp;&nbsp;</th>
<th align="right">Tressage&nbsp;&nbsp;</th>
<th align="right">Échafaudage</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><strong>1</strong></td>
<td align="right">1</td>
<td align="right">1</td>
</tr>

<tr>
<td align="left"><strong>2</strong></td>
<td align="right">1</td>
<td align="right">1</td>
</tr>

<tr>
<td align="left"><strong>3</strong></td>
<td align="right">1</td>
<td align="right">1</td>
</tr>

<tr>
<td align="left"><strong>4</strong></td>
<td align="right">1</td>
<td align="right">1</td>
</tr>

<tr>
<td align="left"><strong>5</strong></td>
<td align="right">1</td>
<td align="right">0.47</td>
</tr>

<tr>
<td align="left"><strong>6</strong></td>
<td align="right">0.998</td>
<td align="right">0.043</td>
</tr>

<tr>
<td align="left"><strong>7</strong></td>
<td align="right">0.998</td>
<td align="right"></td>
</tr>

<tr>
<td align="left"><strong>8</strong></td>
<td align="right">0.39</td>
<td align="right"></td>
</tr>

<tr>
<td align="left"><strong>9</strong></td>
<td align="right">0.39</td>
<td align="right"></td>
</tr>

<tr>
<td align="left"><strong>10</strong></td>
<td align="right">0.038</td>
<td align="right"></td>
</tr>

<tr>
<td align="left"><strong>11</strong></td>
<td align="right">0.038</td>
<td align="right"></td>
</tr>

<tr>
<td align="left"><strong>12</strong></td>
<td align="right">0.003</td>
<td align="right"></td>
</tr>
</tbody>
</table>

<p>Muni de ces nouvelles probabilités, nous pouvons à nouveau calculer l&rsquo;espérance du transitoire afin d&rsquo;obtenir un ordre de grandeur du nombre de pas nécessaires pour résoudre la grille par cette deuxième approche. Il est toutefois important de souligner qu&rsquo;il est ici nécessaire de corriger les valeurs obtenues. En effet, les probabilités de transition témoignent ici de la possibilité qu&rsquo;il existe un mot compatible avec chacune des colonnes traversées, mais encore faut-il trouver ce mot ! Ce n&rsquo;est en aucun cas immédiat puisque cela peut nécessiter d&rsquo;en tester plusieurs pour y parvenir. Il demeure tout de même possible d&rsquo;y arriver intelligemment en gardant le compte de toutes les lettres incompatibles, ce qui permet d&rsquo;épuiser tout le dictionnaire en un maximum de $26.S$ étapes.</p>

<p>La table qui suit permet de comparer le nombre de pas propres aux deux méthodes exposées avec, pour la dernière, une correction d&rsquo;un facteur pifométré à $10.S$.</p>

<table>
<thead>
<tr>
<th align="left">$S$</th>
<th align="center">&nbsp; Nombre de grilles&nbsp;</th>
<th align="right">&nbsp; #pas, tressage &nbsp;</th>
<th align="right">&nbsp; #pas, échauf. &nbsp;</th>
<th align="right">&nbsp; Résolution</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"></td>
<td align="center"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">5&nbsp;&nbsp;</td>
<td align="center">$10^{19}$</td>
<td align="right">$10^{3.4}$</td>
<td align="right">$10^{2.8}$</td>
<td align="right">0,5 ms</td>
</tr>

<tr>
<td align="left">6&nbsp;&nbsp;</td>
<td align="center">$10^{24.8}$</td>
<td align="right">$10^{6.3}$</td>
<td align="right">$10^{3.8}$</td>
<td align="right">6 ms</td>
</tr>

<tr>
<td align="left">7&nbsp;&nbsp;</td>
<td align="center">$10^{30.5}$</td>
<td align="right">$10^{11}$</td>
<td align="right">$10^{5.7}$</td>
<td align="right">0,5 sec.</td>
</tr>

<tr>
<td align="left">8&nbsp;&nbsp;</td>
<td align="center">$10^{36.0}$</td>
<td align="right">$10^{17.8}$</td>
<td align="right">$10^{8.5}$</td>
<td align="right">5 min.</td>
</tr>
</tbody>
</table>

<p>Bien que cette étude soit théorique, le nombre de pas moyen pour résoudre ces grilles parfaites dans Wizium est très proches des valeurs affichées ici. Cela montre bien à quel point le choix de l&rsquo;algorithme est primordial lorsque la taille du problème à traiter est grande. Pour les grilles de 8x8, il nous a permis de passer d&rsquo;une résolution en mille-milliards de milliards d&rsquo;années à 20.000 ans, puis à une poignée de minutes. Il s&rsquo;agit d&rsquo;une accélération vertigineuse de pas moins de 26 ordres de grandeur, ce qui est plus ou moins équivalent à réduire la taille d&rsquo;une galaxie à celle d&rsquo;une ville puis à celle d&rsquo;une bactérie.</p>

<p><a href="../part3">Chapitre suivant</a></p>
        </span>
      </div>
      <div class="f5 mid-gray">
      <br>
      N'hésitez pas à partager
      

<a class="resp-sharing-button__link" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjsgonsette.github.io%2fprojects%2fwizium%2fpart2%2f" target="_blank" rel="noopener" aria-label="">
  <div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.77 7.46H14.5v-1.9c0-.9.6-1.1 1-1.1h3V.5h-4.33C10.24.5 9.5 3.44 9.5 5.32v2.15h-3v4h3v12h5v-12h3.85l.42-4z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://twitter.com/intent/tweet/?text=Wizium%20-%20Mon%20g%c3%a9n%c3%a9rateur%20de%20mots%20crois%c3%a9s - De%20la%20bonne%20fa%c3%a7on%20de%20paver%20sa%20grille&amp;url=https%3a%2f%2fjsgonsette.github.io%2fprojects%2fwizium%2fpart2%2f" target="_blank" rel="noopener" aria-label="">
  <div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M23.44 4.83c-.8.37-1.5.38-2.22.02.93-.56.98-.96 1.32-2.02-.88.52-1.86.9-2.9 1.1-.82-.88-2-1.43-3.3-1.43-2.5 0-4.55 2.04-4.55 4.54 0 .36.03.7.1 1.04-3.77-.2-7.12-2-9.36-4.75-.4.67-.6 1.45-.6 2.3 0 1.56.8 2.95 2 3.77-.74-.03-1.44-.23-2.05-.57v.06c0 2.2 1.56 4.03 3.64 4.44-.67.2-1.37.2-2.06.08.58 1.8 2.26 3.12 4.25 3.16C5.78 18.1 3.37 18.74 1 18.46c2 1.3 4.4 2.04 6.97 2.04 8.35 0 12.92-6.92 12.92-12.93 0-.2 0-.4-.02-.6.9-.63 1.96-1.22 2.56-2.14z"/></svg>
    </div>
  </div>
</a>






<a class="resp-sharing-button__link" href="mailto:?subject=Wizium%20-%20Mon%20g%c3%a9n%c3%a9rateur%20de%20mots%20crois%c3%a9s - De%20la%20bonne%20fa%c3%a7on%20de%20paver%20sa%20grille&amp;body=https%3a%2f%2fjsgonsette.github.io%2fprojects%2fwizium%2fpart2%2f" target="_self" rel="noopener" aria-label="">
  <div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 4H2C.9 4 0 4.9 0 6v12c0 1.1.9 2 2 2h20c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7.25 14.43l-3.5 2c-.08.05-.17.07-.25.07-.17 0-.34-.1-.43-.25-.14-.24-.06-.55.18-.68l3.5-2c.24-.14.55-.06.68.18.14.24.06.55-.18.68zm4.75.07c-.1 0-.2-.03-.27-.08l-8.5-5.5c-.23-.15-.3-.46-.15-.7.15-.22.46-.3.7-.14L12 13.4l8.23-5.32c.23-.15.54-.08.7.15.14.23.07.54-.16.7l-8.5 5.5c-.08.04-.17.07-.27.07zm8.93 1.75c-.1.16-.26.25-.43.25-.08 0-.17-.02-.25-.07l-3.5-2c-.24-.13-.32-.44-.18-.68s.44-.32.68-.18l3.5 2c.24.13.32.44.18.68z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fjsgonsette.github.io%2fprojects%2fwizium%2fpart2%2f&amp;media=https://jsgonsette.github.io/&amp;description=Wizium%20-%20Mon%20g%c3%a9n%c3%a9rateur%20de%20mots%20crois%c3%a9s - De%20la%20bonne%20fa%c3%a7on%20de%20paver%20sa%20grille" target="_blank" rel="noopener" aria-label="">
  <div class="resp-sharing-button resp-sharing-button--pinterest resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12.14.5C5.86.5 2.7 5 2.7 8.75c0 2.27.86 4.3 2.7 5.05.3.12.57 0 .66-.33l.27-1.06c.1-.32.06-.44-.2-.73-.52-.62-.86-1.44-.86-2.6 0-3.33 2.5-6.32 6.5-6.32 3.55 0 5.5 2.17 5.5 5.07 0 3.8-1.7 7.02-4.2 7.02-1.37 0-2.4-1.14-2.07-2.54.4-1.68 1.16-3.48 1.16-4.7 0-1.07-.58-1.98-1.78-1.98-1.4 0-2.55 1.47-2.55 3.42 0 1.25.43 2.1.43 2.1l-1.7 7.2c-.5 2.13-.08 4.75-.04 5 .02.17.22.2.3.1.14-.18 1.82-2.26 2.4-4.33.16-.58.93-3.63.93-3.63.45.88 1.8 1.65 3.22 1.65 4.25 0 7.13-3.87 7.13-9.05C20.5 4.15 17.18.5 12.14.5z"/></svg>
    </div>
  </div>
</a>


    </div>
    </article>
    <aside class="ph3 mt2 mt6-ns">
      







  <div class="bg-light-gray pa3">
    <ul>
      <li class="list b mb3">
        2 autres articles dans Wizium
      </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/projects/wizium/part1/" class="link ph2 pv2 db black">
            La longue voie du backtracking
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/projects/wizium/part2/" class="link ph2 pv2 db black o-50">
            De la bonne façon de paver sa grille
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/projects/wizium/part3/" class="link ph2 pv2 db black">
            Ma tactique de course est évidente: j&#39;appuie sur l&#39;accélérateur et je fonce
          </a>
        </li>
      
    </ul>
  </div>


    </aside>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jsgonsette.github.io/" >
    &copy; 2019 Jean-Sébastien Gonsette
  </a>
  <p align="right">






  <a href="https://www.linkedin.com/in/jsgonsette/" class="link-transition linkedin link dib z-999 pt3 pt0-l mr2" title="LinkedIn link">
    <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

  </a>


  <a href="https://github.com/jsgonsette" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>

</p>
  </div>
</footer>

    <script src="https://jsgonsette.github.io/dist/app.bundle.js" async></script>

  </body>
</html>
