<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Jean-Sébastien Gonsette  | De la bonne façon de paver sa grille</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.31.1" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    <link href='https://jsgonsette.github.io/dist/main.css' rel='stylesheet' type="text/css" />
    <link href='https://jsgonsette.github.io/css/jsg.css' rel='stylesheet' type="text/css" />
    
      
    

    

    <meta property="og:title" content="De la bonne façon de paver sa grille" />
<meta property="og:description" content="La méthode utilisée précédemment pour remplir la grille se voulait excessivement naïve, car il est tout à fait effroyable de ne tester la validité de la solution qu&rsquo;une fois tous les mots placés. Le problème étant combinatoire, la nature exponentielle des combinaisons de mots sont comme autant de branches, branchettes et puis brindilles se subivisant effroyablement rapidement. Aussi vaut-il mieux se rendre compte le plus tôt possible que la voie choisie n&rsquo;aboutira à aucune solution, de manière à couper la branche morte dès le début et ne pas perdre du précieux temps de calcul au fin fond de son arborescence." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jsgonsette.github.io/wizium/part2/" />



<meta property="article:published_time" content="2019-05-19T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2019-05-19T00:00:00&#43;00:00"/>











<meta itemprop="name" content="De la bonne façon de paver sa grille">
<meta itemprop="description" content="La méthode utilisée précédemment pour remplir la grille se voulait excessivement naïve, car il est tout à fait effroyable de ne tester la validité de la solution qu&rsquo;une fois tous les mots placés. Le problème étant combinatoire, la nature exponentielle des combinaisons de mots sont comme autant de branches, branchettes et puis brindilles se subivisant effroyablement rapidement. Aussi vaut-il mieux se rendre compte le plus tôt possible que la voie choisie n&rsquo;aboutira à aucune solution, de manière à couper la branche morte dès le début et ne pas perdre du précieux temps de calcul au fin fond de son arborescence.">


<meta itemprop="datePublished" content="2019-05-19T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-05-19T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1460">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="De la bonne façon de paver sa grille"/>
<meta name="twitter:description" content="La méthode utilisée précédemment pour remplir la grille se voulait excessivement naïve, car il est tout à fait effroyable de ne tester la validité de la solution qu&rsquo;une fois tous les mots placés. Le problème étant combinatoire, la nature exponentielle des combinaisons de mots sont comme autant de branches, branchettes et puis brindilles se subivisant effroyablement rapidement. Aussi vaut-il mieux se rendre compte le plus tôt possible que la voie choisie n&rsquo;aboutira à aucune solution, de manière à couper la branche morte dès le début et ne pas perdre du précieux temps de calcul au fin fond de son arborescence."/>

      
    
  </head>

  <body class="ma0 avenir bg-near-white">

    

  
  
  <header class="cover bg-top" style="background-image: url('https://jsgonsette.github.io/images/Wizium/PavingFlat.jpg');">
    <div class="pb3-m pb6-l bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jsgonsette.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Jean-Sébastien Gonsette
    </a>
    <div class="flex-l items-center">
      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/42/" title="42 page">
              42
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/enigmes/" title="Énigmes page">
              Énigmes
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/ipendulum/" title="iPendulum page">
              iPendulum
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/wizium/" title="Wizium page">
              Wizium
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/contact/" title="À propos page">
              À propos
            </a>
          </li>
          
        </ul>
      
      






  <a href="https://www.linkedin.com/in/jsgonsette/" class="link-transition linkedin link dib z-999 pt3 pt0-l mr2" title="LinkedIn link">
    <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

  </a>


  <a href="https://github.com/jsgonsette" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>


    </div>
  </div>
</nav>

      <div class="tc-l pv6 ph3 ph4-ns">
        <h1 class="f2 f1-l fw2 white-90 mb0 lh-title">De la bonne façon de paver sa grille</h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <p class="f6 b helvetica tracked">
          
            Wizium
          
        </p>
        <h1 class="f1">
          De la bonne façon de paver sa grille
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
        <span class="justified">
        

<p>La méthode utilisée précédemment pour remplir la grille se voulait excessivement naïve, car il est tout à fait effroyable de ne tester la validité de la solution qu&rsquo;une fois tous les mots placés. Le problème étant combinatoire, la nature exponentielle des combinaisons de mots sont comme autant de branches, branchettes et puis brindilles se subivisant effroyablement rapidement. Aussi vaut-il mieux se rendre compte le plus tôt possible que la voie choisie n&rsquo;aboutira à aucune solution, de manière à couper la branche morte dès le début et ne pas perdre du précieux temps de calcul au fin fond de son arborescence.</p>

<p>



  


<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="/js/load-photoswipe.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin="anonymous"></script>


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

</p>

<p>Reste maintenant à savoir quelle est la manière la plus efficace pour procéder, de façon à anticiper aussi vite que possible une quelconque situation de blocage. Je ne prétends pas détenir la réponse ultime à cette question et je me contenterai de présenter deux méthodes possible, l&rsquo;une d&rsquo;elles est celle implémentée dans Wizum.</p>

<h2 id="première-méthode-le-tressage">Première méthode: le tressage</h2>

<p>Cette technique est assez naturelle et consiste à alterner la pose des mots horizontalement et verticalement, de haut en bas et de gauche à droite. L&rsquo;entrelaçage des mots est alors maximal et permet de détecter très tôt l&rsquo;impossibilité de placer un $n^{ème}$ mot. Le cas échéant, il suffira alors de modifier le mot précédent au niveau de la lettre qui a conduit à ce blocage.</p>


<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/Wizium/Weave.gif" alt="Construction par entrelaçage vertical-horizontal des mots."/>
    </div>
    <a href="/images/Wizium/Weave.gif" itemprop="contentUrl"></a>
      <figcaption>
          <p>Construction par entrelaçage vertical-horizontal des mots.</p>
      </figcaption>
  </figure>
</div>


<p>Dans l&rsquo;exemple ci-dessus, la pose du troisième mot vertical avec <strong>CREOLE</strong> empêche ensuite de placer le quatrième mot horizontal. Il n&rsquo;existe en effet aucune solution de six lettres commençant par <strong>REO</strong>. Cela invalide le mot précédent et conduit immédiatement à le remplacer par quelque chose ne contenant pas de <strong>O</strong> sur la quatrième rangée. Toutes les cases vides de la grille sont alors autant de combinaisons de mots qui ne devront pas être testées.</p>

<p>Essayons maintenant d&rsquo;évaluer le gain que cette méthodologie peut offir. On peut l&rsquo;étudier en l&rsquo;abordant comme une <strong>chaine de Markov discrète</strong>, c&rsquo;est à dire que l&rsquo;algorithme de pavage de la grille peu être assimilé à un processus stochastique dont l&rsquo;état correspond uniquement à l&rsquo;indice du mot à placer. Le succès ou l&rsquo;échec de cette opération conduit soit à avancer au mot suivant ou, au contraire, à reculer pour modifier le précédent. Ce processus n&rsquo;est pas réellement homogène car, techniquement, les probabilités de transitions ne dépendent pas seulement de la partie de la grille que l&rsquo;on essaie de remplir, mais aussi de toutes les combinaisons de lettres qui ont déjà été épuisées. Nous nous contenterons toutefois de cette approximation dans la mesure où nous voulons seulement estimer l&rsquo;ordre de grandeur du gain apporté par cette approche.</p>

<p>Pour ce faire, désignons par ${w_h}_i$ les $S$ emplacements horizontaux et, de la même manière, par ${w_v}_i$ pour les emplacements verticaux. La probabilité qu&rsquo;il existe un mot du dictionnaire pour remplir chacun d&rsquo;eux est donné par:</p>

<p>$${p_{h}}_i = 1 - (1 - {p_{co}}^i)^N$$</p>

<p>$${p_{v}}_i = 1 - (1 - {p_{co}}^{i+1})^N$$</p>

<p>avec $i=0&hellip;S-1$. Ces formules traduisent simplement la probabilité qu&rsquo;un certain nombre de lettres assemblées au hasard correspondent à une partie de mot valide. Plus $i$ augmente, plus les chances diminuent à cause du nombre croissant de lettres avec lesquelles il faut composer. Nous pouvons alors modélier le processus de <em>backtracking</em> par cette chaine de Markov.</p>

<p>Sans trop entrer dans les détails mathématiques, un processus de Markov peut s&rsquo;étudier au travers des propriétés de sa matrice de transition $P$. Celle-ci est construite de telle sorte que chaque élément $(P)_{ij}$ soit égal à la probabilité de transition entre l&rsquo;état $i$ et l&rsquo;état $j$.</p>

<p>$$P=\begin{pmatrix}
    0 &amp; 1-{p_v}_0 &amp; 0  &amp; 0 &amp; 0\newline
    {p_h}_0 &amp; 0 &amp; \ddots &amp; 0 &amp; 0\newline
    0 &amp; {p_v}_0 &amp; 0 &amp; {p_h} _ {S-1} &amp; 0\newline
    0 &amp; 0 &amp; \ddots &amp; 0 &amp; 0 \newline
    0 &amp; 0 &amp; 0 &amp; {p_h} _ {S-1} &amp; 1
\end{pmatrix}$$</p>

<p>de telle sorte que si $\phi(n)$ représente la distribution de probabilité de l&rsquo;état du processus au temps $n$, alors la distribution au pas suivant sera donnée par:</p>

<p>$$\phi(n+1) = P. \phi(n)$$</p>

<p>Le dernier état est ce que l&rsquo;on appelle un état <strong>absorbant</strong>, car il correspond à la construction d&rsquo;une grille complète valide et stoppe la recherche. Cela peut se voir sur le graphe à cause de l&rsquo;unique transition de probabilité 1 qui cycle sur cet état final. Cette propriété se constate aussi dans la dernière colonne de la matrice $P$ qui ne permet pas de redistribuer les probabilités autre part que dans le dernier état. A l&rsquo;inverse, tous les autre états sont dit <strong>transitoires</strong>, dans la mesure ou rien de garantit que l&rsquo;algorithme les traversera plus d&rsquo;une fois. La valeur qu&rsquo;il est alors particulièrement intéressant d&rsquo;étudier concerne <em>le temps passé en moyenne dans ces états transitoires avant d&rsquo;atteindre l&rsquo;état final</em>.</p>

<p>Pour y arriver, il nous faut d&rsquo;abord réécrire la matrice $P$ en mettant en évidence cette distinction, grâce à la matrice carrée $Q$ capturant cet aspect transitoire, ainsi qu&rsquo;au vecteur $R$ représentant l&rsquo;état absorbant.</p>

<p>$$P=\begin{pmatrix}
    Q &amp; \boldsymbol{0}\newline
    R &amp; 1\newline<br />
\end{pmatrix}$$</p>

<p>Cela permet ensuite de calculer la matrice $N = (I-Q)^{-1}$ grâce à laquelle on peut trouver la durée moyenne du transitoire, ou dit autrement, le nombre de pas moyen de l&rsquo;algorithme de <em>backtracking</em> (suivez ce <a href="https://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/Chapter11.pdf">lien</a> pour plus d&rsquo;information à ce sujet).</p>

<p>Examinons maintenant les nouvelles estimations du nombre de pas nécessaires pour résoudre nos grilles parfaites de différentes tailles, afin d&rsquo;apprécier le gain apporté par cette nouvelle méthode.</p>

<table>
<thead>
<tr>
<th align="left">$S$</th>
<th align="center">&nbsp; Nombre de grilles&nbsp;</th>
<th align="right">&nbsp; #pas, naïf &nbsp;</th>
<th align="right">&nbsp; #pas, tressage &nbsp;</th>
<th align="right">&nbsp; Résolution</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"></td>
<td align="center"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>

<tr>
<td align="left">5&nbsp;&nbsp;</td>
<td align="center">$10^{19}$</td>
<td align="right">$10^{8.7}$</td>
<td align="right">$10^{3.4}$</td>
<td align="right">1ms</td>
</tr>

<tr>
<td align="left">6&nbsp;&nbsp;</td>
<td align="center">$10^{24.8}$</td>
<td align="right">$10^{15.0}$</td>
<td align="right">$10^{6.3}$</td>
<td align="right">2s</td>
</tr>

<tr>
<td align="left">7&nbsp;&nbsp;</td>
<td align="center">$10^{30.5}$</td>
<td align="right">$10^{23.7}$</td>
<td align="right">$10^{11}$</td>
<td align="right">1 journée</td>
</tr>

<tr>
<td align="left">8&nbsp;&nbsp;</td>
<td align="center">$10^{36.0}$</td>
<td align="right">$10^{34.8}$</td>
<td align="right">$10^{16.9}$</td>
<td align="right">2500 ans</td>
</tr>
</tbody>
</table>

<p>La dernière colonne estime à nouveau le temps de résolution à raison d&rsquo;un million de tests par seconde. Il va sans dire que le progrès est spectaculaire, la résolution d&rsquo;une grille 7x7 pouvant maintenant s&rsquo;envisager sans problème, en passant d&rsquo;un temps de 10 millards d&rsquo;années (ce qui n&rsquo;est pas loin de l&rsquo;age de l&rsquo;univers) à seulement une journée. Les grilles 8x8 restent toutefois encore hors de portée avec cette méthode, du moins si l&rsquo;on se cantonne à l&rsquo;usage d&rsquo;un PC conventionnel.</p>

<h2 id="deuxième-méthode-l-échaffaudage">Deuxième méthode: l&rsquo;échaffaudage</h2>

<p>La technique que je m&rsquo;apprete à décrire constitue la base de l&rsquo;algorithme implémenté dans Wizium. Elle résulte avant toute chose d&rsquo;une longue recherche ponctuée de beaucoup d&rsquo;essais et de nombreuses erreurs, et pas de l&rsquo;analyse que vous êtes en train de lire, car cette dernière est arrivée bien plus tard. Malgrès son élaboration empirique, son principal avantage est de ne pas souffrir des mêmes faiblesses que la méthode précédente. Elle est beaucoup plus directe et anticipe mieux les problèmes. Pour s&rsquo;en rendre compte, commençons par jetter un oeil à la construction de la grille qui suit:</p>



<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/Wizium/WeaveFail.gif" alt="Construction pathologique par entrelaçage vertical-horizontal des mots. C&#39;est seulement au dernier statde de l&#39;algorithme que l&#39;impossibilité de la dernière colonne est détectée."/>
    </div>
    <a href="/images/Wizium/WeaveFail.gif" itemprop="contentUrl"></a>
      <figcaption>
          <p>Construction pathologique par entrelaçage vertical-horizontal des mots. C&#39;est seulement au dernier statde de l&#39;algorithme que l&#39;impossibilité de la dernière colonne est détectée.</p>
      </figcaption>
  </figure>
</div>


<p>Cette construction pathologique a été imaginée sur mesure, mais illustre néanmoins une tare inévitable de la méthode de <em>tressage</em>: lorsque l&rsquo;on place les derniers mots, le succès de l&rsquo;opération joue tout sur la chance et rien sur l&rsquo;anticipation. C&rsquo;est ce qui peut se voir dans cet exemple, la pose du deuxième mot horizontal engendre un blocage inévitable car il empêche de placer ensuite un mot verticalement sur la dernière colonne. Mais rien dans l&rsquo;algorithme ne permet ensuite de détecter cette impasse et celui-ci continura laborieusement à constuire une grille qui est vouée à l&rsquo;échec. C&rsquo;est seulement lors de la pose du dernier mot que la procédure commencera à revenir en arrière pour résoudre la situation, et il devra pour ça défaire presque toute la grille.</p>

<p>Pour éviter ce genre de contrariétés, il est nécessaire et suffisant de vérifier qu&rsquo;il soit encore possible de placer un mot verticalement sur chaque colonne à chaque fois que l&rsquo;on choisit un mot horizontal. Mais en procédant de la sorte, il n&rsquo;est en fait même plus nécessaire de placer aucun mot verticalement. L&rsquo;empilage de mots horizontaux suffit, dans la mesure ou celui-ci se réalise de manière éclairée: l&rsquo;algorithme s&rsquo;assure continuellement que l&rsquo;on n&rsquo;aura pas de mauvaise surprise à la fin. Il n&rsquo;est donc plus question ici de jetter les mots en vracs pour espérer en sortir une grille valide à la fin, il s&rsquo;agit plutôt d&rsquo;empiler les mots avec soin. Il est bien sûr possible que, à un moment, aucun mot du dictionnaire ne satisfasse cette constrainte. Mais dans ce cas le blocage est identifié au plus tôt et permet tout de suite de revenir en arrière, sans s&rsquo;embarquer dans une recherche stérile. Cette méthode est illustrée dans l&rsquo;animation qui suit.</p>

<p>À suivre</p>

        </span>
      </div>
    </article>
    <aside class="ph3 mt2 mt6-ns">
      







  <div class="bg-light-gray pa3">
    <ul>
      <li class="list b mb3">
        1 autre article
      </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/wizium/part1/" class="link ph2 pv2 db black">
            La longue voie du backtracking
          </a>
        </li>
      
        <li class="list f5 w-100 hover-bg-white nl1">
          
          <a href="/wizium/part2/" class="link ph2 pv2 db black o-50">
            De la bonne façon de paver sa grille
          </a>
        </li>
      
    </ul>
  </div>


    </aside>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jsgonsette.github.io/" >
    &copy; 2019 Jean-Sébastien Gonsette
  </a>
  






  <a href="https://www.linkedin.com/in/jsgonsette/" class="link-transition linkedin link dib z-999 pt3 pt0-l mr2" title="LinkedIn link">
    <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

  </a>


  <a href="https://github.com/jsgonsette" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>


  </div>
</footer>

    <script src="https://jsgonsette.github.io/dist/app.bundle.js" async></script>

  </body>
</html>
